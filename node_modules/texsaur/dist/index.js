/// <reference path="../JSX.d.ts" />
import JsxDom from './dom';
import * as svg from './svg';
function __jsx(tag, properties, ...children) {
    const { document, Node } = JsxDom;
    if (typeof tag === 'function') {
        return tag(properties ?? {}, children);
    }
    if (svg.isSvgTag(tag)) {
        return svg.parseSvgElement(tag, properties ?? {}, ...children);
    }
    const element = document.createElement(tag);
    let map = (properties ?? {});
    let prop;
    for (prop of Object.keys(map)) {
        const warn = (expected, actual) => console.warn(tag, `received incorrect value type for property '${prop}': expected `, expected, `instead of`, typeof actual);
        // Extract values:
        prop = prop.toString();
        const value = map[prop];
        // Map known properties:
        switch (prop) {
            case "class": {
                if (typeof value === 'string') {
                    element.className = value;
                }
                else {
                    warn('string', typeof value);
                }
                continue;
            }
            case "style": {
                if (typeof value === 'object') {
                    for (const [k, v] of Object.entries(value)) {
                        const styleProperty = k;
                        if (typeof v !== 'string') {
                            continue;
                        }
                        element.style[styleProperty] = v;
                    }
                }
                else if (typeof value === 'string') {
                    break;
                }
                else {
                    warn('object', typeof value);
                }
                continue;
            }
        }
        // Event callbacks:
        if (/^on/.test(prop)) {
            if (typeof value === 'function') {
                element.addEventListener(prop.substring(2), map[prop]);
            }
            else {
                warn('function', typeof value);
            }
            continue;
        }
        // Everything else:
        try {
            const anyReference = element;
            if (typeof anyReference[prop] === 'undefined') {
                // As a fallback, attempt to set an attribute:
                element.setAttribute(prop, value);
            }
            else {
                anyReference[prop] = value;
            }
        }
        catch (error) {
            console.error(`Could not set ${prop} on ${element.tagName}`, error);
            warn(typeof element[prop], typeof value);
        }
    }
    // append children
    for (let child of children.flat()) {
        if (child instanceof Node) {
            element.appendChild(child);
            continue;
        }
        if (Array.isArray(child)) {
            element.append(...child);
            continue;
        }
        element.append(child);
    }
    return element;
}
function Fragment(_, children) {
    return children;
}
const jsx = __jsx;
jsx.Fragment = Fragment;
export { default as JsxDom } from './dom';
export default jsx;
